#include "gpu/blocks/shader_array/shader_unit.h"
#include "gpu/definitions/register_allocator.h"
#include "gpu/util/conversions.h"
#include "gpu/util/math.h"
#include "gpu/util/os_interface.h"
#include "gpu/util/transfer.h"

#include <algorithm>

void ShaderUnit::main() {
    bool handshakeAlreadyEstablished = false;

    while (true) {
        // Read ISA header
        Isa::Command::Command command = {};
        Transfer::receiveArray(request.inpSending, request.inpData, request.outReceiving, command.dummy.raw, Isa::commandSizeInDwords, &profiling.outBusy, !handshakeAlreadyEstablished);
        handshakeAlreadyEstablished = command.dummy.hasNextCommand;

        switch (command.dummy.commandType) {
        case Isa::Command::CommandType::ExecuteIsa:
            processExecuteIsaCommand(reinterpret_cast<Isa::Command::CommandExecuteIsa &>(command));
            break;
        case Isa::Command::CommandType::StoreIsa:
            processStoreIsaCommand(reinterpret_cast<Isa::Command::CommandStoreIsa &>(command));
            break;
        default:
            FATAL_ERROR("Unknown command type");
        }
    }
}

void ShaderUnit::processStoreIsaCommand(Isa::Command::CommandStoreIsa command) {
    const uint32_t isaSize = command.programLength;
    this->isaMetadata = command;
    for (int i = 0; i < isaSize; i++) {
        wait();
        this->isa[i] = request.inpData.read();
    }
}

void ShaderUnit::processExecuteIsaCommand(Isa::Command::CommandExecuteIsa command) {
    // Clear all registers to 0
    static_assert(std::is_pod_v<Registers>);
    memset(&registers, 0, sizeof(registers));

    // Stream-in values for input registers
    const auto threadCount = nonZeroCountToInt(command.threadCount);
    initializeInputRegisters(threadCount);

    // Execute isa
    profiling.outThreadsStarted = profiling.outThreadsStarted.read() + threadCount;
    executeInstructions(isaMetadata.programLength, threadCount);
    profiling.outThreadsFinished = profiling.outThreadsFinished.read() + threadCount;

    // Stream-out values from output registers
    uint32_t outputStream[Isa::registerComponentsCount * Isa::maxInputOutputRegisters * Isa::simdSize];
    uint32_t outputStreamSize = {};
    appendOutputRegistersValues(threadCount, outputStream, outputStreamSize);

    Transfer::sendArray(response.inpReceiving, response.outSending, response.outData, outputStream, outputStreamSize);
}

void ShaderUnit::initializeInputRegisters(uint32_t threadCount) {
    // Get info about input components
    const bool isFs = isaMetadata.programType == Isa::Command::ProgramType::FragmentShader;
    const uint32_t inputsCount = nonZeroCountToInt(isaMetadata.inputsCount);
    Isa::RegisterSelection inputRegisterIndices[4] = {};
    uint32_t inputComponentsCounts[4] = {};
    uint32_t inputTotalComponentCount = 0;
    for (int inputIndex = 0; inputIndex < inputsCount; inputIndex++) {
        inputRegisterIndices[inputIndex] = getInputOutputRegisterIndex(true, inputIndex);
        if (isFs && inputIndex == 0) {
            inputComponentsCounts[inputIndex] = 3; // we always pass x,y,z position per request. It is hardcoded in FS and SF blocks.
        } else {
            inputComponentsCounts[inputIndex] = nonZeroCountToInt(getInputOutputSize(true, inputIndex));
        }
        inputTotalComponentCount += inputComponentsCounts[inputIndex];
    }

    // Get info about unforms
    const uint32_t uniformsCount = isaMetadata.uniformsCount;
    uint32_t uniformsTotalComponentCount = 0;
    for (size_t uniformIndex = 0; uniformIndex < uniformsCount; uniformIndex++) {
        uniformsTotalComponentCount += nonZeroCountToInt(getUniformSize(uniformIndex));
    }

    // Receive per thread inputs from SF. In normal shaders all input attributes will be passed and stored in registers.
    // In FS only xy position is passed and we store it in the first input register. They will be interpolated later by
    // code generated by the compiler and results will be stored to actual input registers defined in isaMetadata.
    constexpr size_t maxPerThreadDwords = Isa::simdSize * Isa::maxInputOutputRegisters * Isa::registerComponentsCount;
    uint32_t perThreadDwords[maxPerThreadDwords];
    if (isFs) {
        const auto dwordsCout = threadCount * 2;
        Transfer::receiveArray(request.inpSending, request.inpData, request.outReceiving, perThreadDwords, dwordsCout, nullptr, false);
    } else {
        const auto dwordsCount = threadCount * inputTotalComponentCount;
        Transfer::receiveArray(request.inpSending, request.inpData, request.outReceiving, perThreadDwords, dwordsCount, nullptr, false);
    }

    // Receive per-request uniform values.
    std::fill_n(uniformDwords, maxUniformDwords, 0);
    if (uniformsTotalComponentCount != 0) {
        Transfer::receiveArray(request.inpSending, request.inpData, request.outReceiving, uniformDwords, uniformsTotalComponentCount, nullptr, false);
    }

    // Receive per-request vertex attributes for FS.
    constexpr size_t maxFsVertexAttributesDwords = verticesInPrimitive * Isa::maxInputOutputRegisters * Isa::registerComponentsCount;
    uint32_t fsVertexAttributesDwords[maxFsVertexAttributesDwords];
    if (isFs) {
        const auto dwordsCout = verticesInPrimitive * inputTotalComponentCount;
        Transfer::receiveArray(request.inpSending, request.inpData, request.outReceiving, fsVertexAttributesDwords, dwordsCout, nullptr, false);
    }

    // Store per-thread inputs in registers
    if (isFs) {
        for (int threadIndex = 0; threadIndex < threadCount; threadIndex++) {
            registers.gpr[threadIndex][inputRegisterIndices[0]].x = perThreadDwords[threadIndex * 2 + 0];
            registers.gpr[threadIndex][inputRegisterIndices[0]].y = perThreadDwords[threadIndex * 2 + 1];
        }
    } else {
        uint32_t stored = 0;
        for (int threadIndex = 0; threadIndex < threadCount; threadIndex++) {
            for (int inputIndex = 0; inputIndex < inputsCount; inputIndex++) {
                const auto componentsCount = inputComponentsCounts[inputIndex];
                const auto registerIndex = inputRegisterIndices[inputIndex];

                VectorRegister &reg = registers.gpr[threadIndex][registerIndex];
                std::memcpy(&reg.x, perThreadDwords + stored, sizeof(int32_t) * componentsCount);
                stored += componentsCount;
            }
        }
    }

    // Store per-request vertex attributes in registers for FS
    if (isFs) {
        RegisterAllocator registerAllocator{isaMetadata};
        uint32_t stored = 0;
        for (int vertexIndex = 0; vertexIndex < verticesInPrimitive; vertexIndex++) {
            for (int inputIndex = 0; inputIndex < inputsCount; inputIndex++) {
                // Determine where to put the per-request attribute value. It doesn't matter to the shader code,
                // but it has to be in sync with the interpolation code generated by the compiler, which will
                // expect the values to be in particular registers.
                Isa::RegisterSelection registerIndex = registerAllocator.allocate();

                // Find the value of attribute we want to store
                const auto componentsCount = inputComponentsCounts[inputIndex];
                VectorRegister regValue = {};
                std::memcpy(&regValue, fsVertexAttributesDwords + stored, sizeof(int32_t) * componentsCount);
                stored += componentsCount;

                // Store the value for each thread
                for (int threadIndex = 0; threadIndex < threadCount; threadIndex++) {
                    registers.gpr[threadIndex][registerIndex] = regValue;
                }
            }
        }
    }
}

void ShaderUnit::appendOutputRegistersValues(uint32_t threadCount, uint32_t *outputStream, uint32_t &outputStreamSize) {
    const uint32_t outputsCount = nonZeroCountToInt(isaMetadata.outputsCount);

    // Get info about components
    Isa::RegisterSelection registerIndices[4] = {};
    uint32_t componentsCounts[4] = {};
    for (int outputIndex = 0; outputIndex < outputsCount; outputIndex++) {
        registerIndices[outputIndex] = getInputOutputRegisterIndex(false, outputIndex);
        componentsCounts[outputIndex] = nonZeroCountToInt(getInputOutputSize(false, outputIndex));
    }

    for (int threadIndex = 0; threadIndex < threadCount; threadIndex++) {
        for (int outputIndex = 0; outputIndex < outputsCount; outputIndex++) {
            const auto registerIndex = registerIndices[outputIndex];
            const auto componentsCount = componentsCounts[outputIndex];

            const VectorRegister &reg = registers.gpr[threadIndex][registerIndex];
            for (int component = 0; component < componentsCount; component++) {
                outputStream[outputStreamSize++] = reg[component];
            }
        }
    }
}

void ShaderUnit::loadUniforms(uint32_t threadCount) {
    const size_t uniformsCount = isaMetadata.uniformsCount;

    size_t offset = 0;
    for (size_t uniformIndex = 0; uniformIndex < uniformsCount; uniformIndex++) {
        const uint32_t componentsCount = nonZeroCountToInt(getUniformSize(uniformIndex));
        const uint32_t registerIndex = getUniformRegisterIndex(uniformIndex);

        VectorRegister registerValue = {};
        for (size_t componentIndex = 0; componentIndex < componentsCount; componentIndex++) {
            registerValue[componentIndex] = this->uniformDwords[offset++];
        }

        for (int threadIndex = 0; threadIndex < threadCount; threadIndex++) {
            registers.gpr[threadIndex][registerIndex] = registerValue;
        }
    }
}

void ShaderUnit::zeroInitializeUnusedRegisters(uint32_t threadCount) {
    static_assert(Isa::generalPurposeRegistersCount == 16);
    uint16_t usedRegisterMask = 0;

    // Find out which registers are used
    const size_t uniformsCount = isaMetadata.uniformsCount;
    for (size_t uniformIndex = 0; uniformIndex < uniformsCount; uniformIndex++) {
        const Isa::RegisterSelection registerIndex = getUniformRegisterIndex(uniformIndex);
        setBit(usedRegisterMask, registerIndex);
    }
    const size_t inputsCount = nonZeroCountToInt(isaMetadata.inputsCount);
    for (size_t inputIndex = 0; inputIndex < inputsCount; inputIndex++) {
        const Isa::RegisterSelection registerIndex = getInputOutputRegisterIndex(true, inputIndex);
        setBit(usedRegisterMask, registerIndex);
    }

    // Clear registers which are not used
    for (Isa::RegisterSelection registerIndex = 0; registerIndex < Isa::generalPurposeRegistersCount; registerIndex++) {
        if (!isBitSet(usedRegisterMask, registerIndex)) {
            for (size_t threadIndex = 0; threadIndex < threadCount; threadIndex++) {
                registers.gpr[threadIndex][registerIndex] = {};
            }
        }
    }
}

NonZeroCount ShaderUnit::getInputOutputSize(bool input, uint32_t index) const {
    switch (index) {
    case 0:
        return input ? isaMetadata.inputSize0 : isaMetadata.outputSize0;
    case 1:
        return input ? isaMetadata.inputSize1 : isaMetadata.outputSize1;
    case 2:
        return input ? isaMetadata.inputSize2 : isaMetadata.outputSize2;
    case 3:
        return input ? isaMetadata.inputSize3 : isaMetadata.outputSize3;
    default:
        FATAL_ERROR("Invalid index for ", __FUNCTION__);
    }
}

NonZeroCount ShaderUnit::getUniformSize(uint32_t index) const {
    switch (index) {
    case 0:
        return isaMetadata.uniformSize0;
    case 1:
        return isaMetadata.uniformSize1;
    case 2:
        return isaMetadata.uniformSize2;
    case 3:
        return isaMetadata.uniformSize3;
    default:
        FATAL_ERROR("Invalid index for ", __FUNCTION__);
    }
}

Isa::RegisterSelection ShaderUnit::getInputOutputRegisterIndex(bool input, uint32_t index) const {
    switch (index) {
    case 0:
        return input ? isaMetadata.inputRegister0 : isaMetadata.outputRegister0;
    case 1:
        return input ? isaMetadata.inputRegister1 : isaMetadata.outputRegister1;
    case 2:
        return input ? isaMetadata.inputRegister2 : isaMetadata.outputRegister2;
    case 3:
        return input ? isaMetadata.inputRegister3 : isaMetadata.outputRegister3;
    default:
        FATAL_ERROR("Invalid index for ", __FUNCTION__);
    }
}

Isa::RegisterSelection ShaderUnit::getUniformRegisterIndex(uint32_t index) const {
    switch (index) {
    case 0:
        return isaMetadata.uniformRegister0;
    case 1:
        return isaMetadata.uniformRegister1;
    case 2:
        return isaMetadata.uniformRegister2;
    case 3:
        return isaMetadata.uniformRegister3;
    default:
        FATAL_ERROR("Invalid index for ", __FUNCTION__);
    }
}

void ShaderUnit::executeInstructions(uint32_t isaSize, uint32_t threadCount) {
    while (registers.pc < isaSize) {
        const Isa::Instruction &instruction = *reinterpret_cast<const Isa::Instruction *>(isa + registers.pc);

        const static auto asf = [](int32_t arg) { return reinterpret_cast<float &>(arg); };
        const static auto asi = [](float arg) { return reinterpret_cast<int32_t &>(arg); };

        switch (instruction.header.opcode) {
        case Isa::Opcode::fadd:
            registers.pc += executeInstructionForLanes(threadCount, instruction.binaryMath, [](int32_t src1, int32_t src2) { return asi(asf(src1) + asf(src2)); });
            break;
        case Isa::Opcode::fadd_imm:
            registers.pc += executeInstructionForLanes(threadCount, instruction.binaryMathImm, [](int32_t src1, int32_t src2) { return asi(asf(src1) + asf(src2)); });
            break;
        case Isa::Opcode::fsub:
            registers.pc += executeInstructionForLanes(threadCount, instruction.binaryMath, [](int32_t src1, int32_t src2) { return asi(asf(src1) - asf(src2)); });
            break;
        case Isa::Opcode::fsub_imm:
            registers.pc += executeInstructionForLanes(threadCount, instruction.binaryMathImm, [](int32_t src1, int32_t src2) { return asi(asf(src1) - asf(src2)); });
            break;
        case Isa::Opcode::fmul:
            registers.pc += executeInstructionForLanes(threadCount, instruction.binaryMath, [](int32_t src1, int32_t src2) { return asi(asf(src1) * asf(src2)); });
            break;
        case Isa::Opcode::fmul_imm:
            registers.pc += executeInstructionForLanes(threadCount, instruction.binaryMathImm, [](int32_t src1, int32_t src2) { return asi(asf(src1) * asf(src2)); });
            break;
        case Isa::Opcode::fdiv:
            registers.pc += executeInstructionForLanes(threadCount, instruction.binaryMath, [](int32_t src1, int32_t src2) { return asi(asf(src1) / asf(src2)); });
            break;
        case Isa::Opcode::fdiv_imm:
            registers.pc += executeInstructionForLanes(threadCount, instruction.binaryMathImm, [](int32_t src1, int32_t src2) { return asi(asf(src1) / asf(src2)); });
            break;
        case Isa::Opcode::fneg:
            registers.pc += executeInstructionForLanes(threadCount, instruction.unaryMath, [](int32_t src) { return asi(-asf(src)); });
            break;
        case Isa::Opcode::fdot:
            registers.pc += executeInstructionForLanes(threadCount, instruction.binaryMath, [](VectorRegister src1, VectorRegister src2) {
                return asi(asf(src1.x) * asf(src2.x) +
                           asf(src1.y) * asf(src2.y) +
                           asf(src1.z) * asf(src2.z) +
                           asf(src1.w) * asf(src2.w));
            });
            break;
        case Isa::Opcode::fcross:
            registers.pc += executeInstructionForLanes(threadCount, instruction.binaryMath, [](VectorRegister src1, VectorRegister src2) {
                return VectorRegister{
                    asi(asf(src1.y) * asf(src2.z) - asf(src1.z) * asf(src2.y)),
                    asi(asf(src1.z) * asf(src2.x) - asf(src1.x) * asf(src2.z)),
                    asi(asf(src1.x) * asf(src2.y) - asf(src1.y) * asf(src2.x)),
                    0,
                };
            });
            break;
        case Isa::Opcode::fcross2:
            registers.pc += executeInstructionForLanes(threadCount, instruction.binaryMath, [](VectorRegister src1, VectorRegister src2) {
                return asi(asf(src1.x) * asf(src2.y) - asf(src1.y) * asf(src2.x));
            });
            break;
        case Isa::Opcode::fmad:
            registers.pc += executeInstructionForLanes(threadCount, instruction.ternaryMath, [](int32_t src1, int32_t src2, int32_t src3) {
                return asi(asf(src1) * asf(src2) + asf(src3));
            });
            break;
        case Isa::Opcode::frcp:
            registers.pc += executeInstructionForLanes(threadCount, instruction.unaryMath, [](int32_t src) { return asi(1 / asf(src)); });
            break;
        case Isa::Opcode::fnorm:
            registers.pc += executeInstructionForLanes(threadCount, instruction.unaryMath, [](VectorRegister src) {
                const float x = asf(src.x);
                const float y = asf(src.y);
                const float z = asf(src.z);
                const float w = asf(src.w);
                const float len = sqrtf(x * x + y * y + z * z + w * w);
                return VectorRegister{
                    asi(x / len),
                    asi(y / len),
                    asi(z / len),
                    asi(w / len),
                };
            });
            break;
        case Isa::Opcode::fmax:
            registers.pc += executeInstructionForLanes(threadCount, instruction.binaryMath, [](int32_t src1, int32_t src2) { return asi(std::max(asf(src1), asf(src2))); });
            break;
        case Isa::Opcode::fmin:
            registers.pc += executeInstructionForLanes(threadCount, instruction.binaryMath, [](int32_t src1, int32_t src2) { return asi(std::min(asf(src1), asf(src2))); });
            break;

        case Isa::Opcode::iadd:
            registers.pc += executeInstructionForLanes(threadCount, instruction.binaryMath, [](int32_t src1, int32_t src2) { return src1 + src2; });
            break;
        case Isa::Opcode::iadd_imm:
            registers.pc += executeInstructionForLanes(threadCount, instruction.binaryMathImm, [](int32_t src1, int32_t src2) { return src1 + src2; });
            break;
        case Isa::Opcode::isub:
            registers.pc += executeInstructionForLanes(threadCount, instruction.binaryMath, [](int32_t src1, int32_t src2) { return src1 - src2; });
            break;
        case Isa::Opcode::isub_imm:
            registers.pc += executeInstructionForLanes(threadCount, instruction.binaryMathImm, [](int32_t src1, int32_t src2) { return src1 - src2; });
            break;
        case Isa::Opcode::imul:
            registers.pc += executeInstructionForLanes(threadCount, instruction.binaryMath, [](int32_t src1, int32_t src2) { return src1 * src2; });
            break;
        case Isa::Opcode::imul_imm:
            registers.pc += executeInstructionForLanes(threadCount, instruction.binaryMathImm, [](int32_t src1, int32_t src2) { return src1 * src2; });
            break;
        case Isa::Opcode::idiv:
            registers.pc += executeInstructionForLanes(threadCount, instruction.binaryMath, [](int32_t src1, int32_t src2) { return src1 / src2; });
            break;
        case Isa::Opcode::idiv_imm:
            registers.pc += executeInstructionForLanes(threadCount, instruction.binaryMathImm, [](int32_t src1, int32_t src2) { return src1 / src2; });
            break;
        case Isa::Opcode::ineg:
            registers.pc += executeInstructionForLanes(threadCount, instruction.unaryMath, [](int32_t src) { return -src; });
            break;
        case Isa::Opcode::imax:
            registers.pc += executeInstructionForLanes(threadCount, instruction.binaryMath, [](int32_t src1, int32_t src2) { return std::max(src1, src2); });
            break;
        case Isa::Opcode::imin:
            registers.pc += executeInstructionForLanes(threadCount, instruction.binaryMath, [](int32_t src1, int32_t src2) { return std::min(src1, src2); });
            break;

        case Isa::Opcode::init:
            registers.pc += executeInstructionForLanes(threadCount, instruction.unaryMathImm, [](int32_t src) { return src; });
            break;
        case Isa::Opcode::mov:
            registers.pc += executeInstructionForLanes(threadCount, instruction.unaryMath, [](int32_t src) { return src; });
            break;
        case Isa::Opcode::swizzle:
            registers.pc += executeInstructionForLanes(threadCount, instruction.swizzle);
            break;
        case Isa::Opcode::trap:
            if (OsInterface::isDebuggerAttached()) {
                OsInterface::breakpoint();
            }
            registers.pc += sizeof(instruction.nullary) / sizeof(uint32_t);
            break;

        case Isa::Opcode::lduni:
            loadUniforms(threadCount);
            registers.pc += sizeof(instruction.nullary) / sizeof(uint32_t);
            break;
        case Isa::Opcode::initregs:
            zeroInitializeUnusedRegisters(threadCount);
            registers.pc += sizeof(instruction.nullary) / sizeof(uint32_t);
            break;

        default:
            FATAL_ERROR("Unknown opcode: ", (uint32_t)instruction.header.opcode);
        }

        wait();
    }
}

int32_t ShaderUnit::executeInstructionLane(uint32_t lane, const Isa::InstructionLayouts::UnaryMath &inst, UnaryFunction function) {
    VectorRegister &src = registers.gpr[lane][inst.src];
    VectorRegister &dest = registers.gpr[lane][inst.dest];
    for (int i = 0; i < 4; i++) {
        if (isBitSet(inst.destMask, 3 - i)) {
            dest[i] = function(src[i]);
        }
    }
    return sizeof(inst) / sizeof(uint32_t);
}

int32_t ShaderUnit::executeInstructionLane(uint32_t lane, const Isa::InstructionLayouts::UnaryMath &inst, UnaryVectorScalarFunction function) {
    VectorRegister &src1 = registers.gpr[lane][inst.src];
    VectorRegister &dest = registers.gpr[lane][inst.dest];

    const uint32_t result = function(src1);
    for (int i = 0; i < 4; i++) {
        if (isBitSet(inst.destMask, 3 - i)) {
            dest[i] = result; // store the same result in each component from mask
        }
    }

    return sizeof(inst) / sizeof(uint32_t);
}

int32_t ShaderUnit::executeInstructionLane(uint32_t lane, const Isa::InstructionLayouts::UnaryMath &inst, UnaryVectorVectorFunction function) {
    VectorRegister &src = registers.gpr[lane][inst.src];
    VectorRegister &dest = registers.gpr[lane][inst.dest];

    const VectorRegister result = function(src);
    for (int i = 0; i < 4; i++) {
        dest = result; // ignore destination mask
    }

    return sizeof(inst) / sizeof(uint32_t);
}

int32_t ShaderUnit::executeInstructionLane(uint32_t lane, const Isa::InstructionLayouts::BinaryMath &inst, BinaryFunction function) {
    VectorRegister &src1 = registers.gpr[lane][inst.src1];
    VectorRegister &src2 = registers.gpr[lane][inst.src2];
    VectorRegister &dest = registers.gpr[lane][inst.dest];
    for (int i = 0; i < 4; i++) {
        if (isBitSet(inst.destMask, 3 - i)) {
            dest[i] = function(src1[i], src2[i]);
        }
    }
    return sizeof(inst) / sizeof(uint32_t);
}

int32_t ShaderUnit::executeInstructionLane(uint32_t lane, const Isa::InstructionLayouts::TernaryMath &inst, TernaryFunction function) {
    VectorRegister &src1 = registers.gpr[lane][inst.src1];
    VectorRegister &src2 = registers.gpr[lane][inst.src2];
    VectorRegister &src3 = registers.gpr[lane][inst.src3];
    VectorRegister &dest = registers.gpr[lane][inst.dest];
    for (int i = 0; i < 4; i++) {
        if (isBitSet(inst.destMask, 3 - i)) {
            dest[i] = function(src1[i], src2[i], src3[i]);
        }
    }
    return sizeof(inst) / sizeof(uint32_t);
}

int32_t ShaderUnit::executeInstructionLane(uint32_t lane, const Isa::InstructionLayouts::BinaryMath &inst, BinaryVectorScalarFunction function) {
    VectorRegister &src1 = registers.gpr[lane][inst.src1];
    VectorRegister &src2 = registers.gpr[lane][inst.src2];
    VectorRegister &dest = registers.gpr[lane][inst.dest];

    const uint32_t result = function(src1, src2);
    for (int i = 0; i < 4; i++) {
        if (isBitSet(inst.destMask, 3 - i)) {
            dest[i] = result; // store the same result in each component from mask
        }
    }

    return sizeof(inst) / sizeof(uint32_t);
}

int32_t ShaderUnit::executeInstructionLane(uint32_t lane, const Isa::InstructionLayouts::BinaryMath &inst, BinaryVectorVectorFunction function) {
    VectorRegister &src1 = registers.gpr[lane][inst.src1];
    VectorRegister &src2 = registers.gpr[lane][inst.src2];
    VectorRegister &dest = registers.gpr[lane][inst.dest];

    const VectorRegister result = function(src1, src2);
    for (int i = 0; i < 4; i++) {
        dest = result; // ignore destination mask
    }

    return sizeof(inst) / sizeof(uint32_t);
}

int32_t ShaderUnit::executeInstructionLane(uint32_t lane, const Isa::InstructionLayouts::UnaryMathImm &inst, UnaryFunction function) {
    const size_t immCount = nonZeroCountToInt(inst.immediateValuesCount);

    VectorRegister &dest = registers.gpr[lane][inst.dest];
    size_t immediateValueIndex = 0;
    for (int i = 0; i < 4; i++) {
        if (isBitSet(inst.destMask, 3 - i)) {
            int32_t src2 = reinterpret_cast<const int32_t &>(inst.immediateValues[immediateValueIndex]);
            dest[i] = function(src2);

            if (immediateValueIndex + 1 < immCount) {
                immediateValueIndex++;
            }
        }
    }
    return 1 + immCount;
}

int32_t ShaderUnit::executeInstructionLane(uint32_t lane, const Isa::InstructionLayouts::BinaryMathImm &inst, BinaryFunction function) {
    const size_t immCount = nonZeroCountToInt(inst.immediateValuesCount);

    VectorRegister &src1 = registers.gpr[lane][inst.src];
    VectorRegister &dest = registers.gpr[lane][inst.dest];
    size_t immediateValueIndex = 0;
    for (int i = 0; i < 4; i++) {
        if (isBitSet(inst.destMask, 3 - i)) {
            int32_t src2 = reinterpret_cast<const int32_t &>(inst.immediateValues[immediateValueIndex]);
            dest[i] = function(src1[i], src2);

            if (immediateValueIndex + 1 < immCount) {
                immediateValueIndex++;
            }
        }
    }
    return 1 + immCount;
}

int32_t ShaderUnit::executeInstructionLane(uint32_t lane, const Isa::InstructionLayouts::Swizzle &inst) {
    VectorRegister &src = registers.gpr[lane][inst.src];
    VectorRegister &dest = registers.gpr[lane][inst.dest];

    dest.x = src[static_cast<size_t>(inst.patternX)];
    dest.y = src[static_cast<size_t>(inst.patternY)];
    dest.z = src[static_cast<size_t>(inst.patternZ)];
    dest.w = src[static_cast<size_t>(inst.patternW)];
    return sizeof(inst) / sizeof(uint32_t);
}
